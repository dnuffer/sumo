#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    line_follower,  sensorLineFollower)
#pragma config(Sensor, in4,    potentiometer,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, dgtl3,  button3,        sensorTouch)
#pragma config(Sensor, dgtl8,  ultrasonic,     sensorSONAR_mm)
#pragma config(Sensor, dgtl11, right_encoder,  sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  sonar_rotate,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           sonar_rotate,  tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port2,           left,          tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port3,           right,         tmotorVex393HighSpeed, openLoop, encoder, encoderPort, dgtl11, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define MAX_INT 32767

#define MAX(x, y) ((x) > (y) ? (x) : (y))
#define MIN(x, y) ((x) > (y) ? (y) : (x))
#define CONSTRAIN(value, min_val, max_val) (MAX(min_val, MIN(value, max_val)))

typedef struct
{
	float CLOSE_ENOUGH;
	float KP;
	float KI;
	float KD;
	long MAX_CHANGE;
	long MIN_OUTPUT;
	long MAX_OUTPUT;
	long EFFECTIVE_MIN;
	float MAX_INTEGRAL;
} pid_controller_t;

typedef struct
{
	long prev_error;
	float integral;
	long prev_output;
	float prev_derivative;
	long prev_time;
} pid_state_t;

void init_pid_state(pid_state_t* s, pid_controller_t* controller)
{
	s->prev_error = controller->CLOSE_ENOUGH + 1;
	s->integral = 0;
	s->prev_output = 0;
	s->prev_derivative = 0;
	s->prev_time = 0;
}

long update_pid_controller(pid_controller_t* controller, pid_state_t* state, long setpoint, long measured_value)
{
	long time = nPgmTime;
	long elapsed_msec = time - state->prev_time;

	// If no measurable time has passed, we can't divide by zero, so return the last output value and don't update anything
	if (elapsed_msec <= 0)
	{
		//writeDebugStreamLine("elapsed_msec == 0!");
		return state->prev_output;
	}

	long error = setpoint - measured_value;

	if (abs(error) > controller->CLOSE_ENOUGH && state->integral < controller->MAX_INTEGRAL)
		state->integral += error * elapsed_msec;

	float derivative = (float)(error - state->prev_error) / elapsed_msec;

	//writeDebugStreamLine("measured_value: %d   integral: %.2f    derivative: %.2f", measured_value, state->integral, derivative);

	float output =
			controller->KP * error
			+ controller->KI * state->integral
			+ controller->KD * derivative;

	//writeDebugStreamLine("output before correction: %.0f", output);

	output = CONSTRAIN(output,
			state->prev_output - controller->MAX_CHANGE,
			state->prev_output + controller->MAX_CHANGE);
	//writeDebugStreamLine("output after correction 1: %.0f", output);

	if (output < -1)
		output = CONSTRAIN(output, controller->MIN_OUTPUT, -controller->EFFECTIVE_MIN);
	else if (output > 1)
		output = CONSTRAIN(output, controller->EFFECTIVE_MIN, controller->MAX_OUTPUT);
	else
		output = 0;

	//writeDebugStreamLine("output after correction: %d", (long)output);

	state->prev_error = error;
	state->prev_output = output;
	state->prev_derivative = derivative;
	state->prev_time = time;

	return output;
}

const int SONAR_BINS = 12;
int sonar_readings[SONAR_BINS];
long sonar_times[SONAR_BINS];

const float ENCODER_COUNTS_PER_REV = 627.2;
const float ENCODER_COUNTS_PER_BIN = ENCODER_COUNTS_PER_REV / SONAR_BINS;

long mod(long x, long y)
{
	if (x < 0)
	{
		x += y * ((-x / y) + 1);
		//return x % y + y;
	}
	return x % y;
}

// This could be 127, but the sonar doesn't work very well (at all) that fast
#define MAX_SONAR_MOTOR_SPEED 30
// The docs say 15, but sometimes even 15 doesn't move. 20 is pretty reliable for a slow movement.
#define MIN_MOTOR_SPEED 20

void init_sonar_pid_controller(pid_controller_t* controller)
{
	controller->CLOSE_ENOUGH = 15;
	controller->KP = -0.6; //0.6 * Ku; //-1.0;
	controller->KI = -0.01;//-0.01; // 2 * KP / Tu; //-0.01;
	controller->KD = -45.0;//-5.0; //KP * Tu / 8; //-100.0;
	controller->MAX_CHANGE = 75;
	controller->MAX_OUTPUT = MAX_SONAR_MOTOR_SPEED;
	controller->MIN_OUTPUT = -controller->MAX_OUTPUT;
	controller->EFFECTIVE_MIN = MIN_MOTOR_SPEED;
	controller->MAX_INTEGRAL = controller->MAX_OUTPUT / controller->KI * 2;
}

void init_drive_pid_controller(pid_controller_t* controller)
{
	controller->CLOSE_ENOUGH = 15;
	controller->KP = -0.6; //0.6 * Ku; //-1.0;
	controller->KI = -0.01;//-0.01; // 2 * KP / Tu; //-0.01;
	controller->KD = -45.0;//-5.0; //KP * Tu / 8; //-100.0;
	controller->MAX_CHANGE = 75;
	controller->MAX_OUTPUT = 127;
	controller->MIN_OUTPUT = -controller->MAX_OUTPUT;
	controller->EFFECTIVE_MIN = 80;
	controller->MAX_INTEGRAL = controller->MAX_OUTPUT / controller->KI * 2;
}

void move_motor_to_position(int motor_id, long desired_encoder, pid_controller_t* controller)
{
	pid_state_t state;
	init_pid_state(&state, controller);

	while (abs(state.prev_error) > controller->CLOSE_ENOUGH)
	{
		long output = update_pid_controller(controller, &state, desired_encoder, nMotorEncoder[motor_id]);
		motor[motor_id] = output;
		wait1Msec(1);
	}

	motor[motor_id] = 0;
}

void move_to_position(long setpoint)
{
	pid_controller_t controller;
	init_sonar_pid_controller(&controller);
	pid_state_t state;
	init_pid_state(&state, &controller);

	while (abs(state.prev_error) > controller.CLOSE_ENOUGH)
	{
		long output = update_pid_controller(&controller, &state, setpoint, nMotorEncoder[sonar_rotate]);

		motor[sonar_rotate] = output;

		int reading = SensorValue[ultrasonic];
		long encoder_reading = nMotorEncoder[sonar_rotate];
		const int MIN_SONAR_DISTANCE = 30;
		if (reading > MIN_SONAR_DISTANCE)
		{
			int bin = mod(encoder_reading / ENCODER_COUNTS_PER_BIN, SONAR_BINS);
			sonar_readings[bin] = reading;
			sonar_times[bin] = nPgmTime;
		}
		wait1Msec(10);
	}

	motor[sonar_rotate] = 0;
}

#define Sonar_Full 0
#define Sonar_Close 1
int sonar_scan_mode = Sonar_Full;

void reset_readings()
{
	for (int i = 0; i < SONAR_BINS; i++)
	{
		sonar_readings[i] = MAX_INT;
		sonar_times[i] = -1;
	}
}

int find_closest_sonar_bin()
{
	int min_idx = 0;
	for (int i = 1; i < SONAR_BINS; i++)
	{
		if (sonar_readings[i] < sonar_readings[min_idx])
			min_idx = i;
	}
	return min_idx;
}

void print_closest()
{
	int min_idx = find_closest_sonar_bin();
	writeDebugStreamLine("closest is at %d deg, distance of %d mm", min_idx * 360/SONAR_BINS, sonar_readings[min_idx]);
}

bool have_recent_sonar_readings()
{
	long cur_time = nPgmTime;
	long max_age = 5 * 1000;
	for (int i = 0; i < SONAR_BINS; i++)
	{
		if (sonar_times[i] < cur_time - max_age || sonar_times[i] == -1 || sonar_readings[i] == MAX_INT)
			return false;
	}
	return true;
}

#define Turn 0
#define Follow_Closest_Object 1
#define Do_Nothing 2
int robot_mode = Do_Nothing;

int get_do_nothing_mode_btn()
{
	// vexRT[Btn6D]
	return SensorValue[button1];
}

int get_turn_btn()
{
	return SensorValue[button2];
}

int get_follow_closest_object_mode_btn()
{
	// vexRT[Btn7U]
	return SensorValue[button3];
}

void check_and_switch_mode()
{
	if (get_do_nothing_mode_btn())
	{
		while (get_do_nothing_mode_btn())
			wait1Msec(100);
		robot_mode = Do_Nothing;
		nMotorEncoder[right] = 0;
		writeDebugStreamLine("Switching to Do_Nothing mode");
	}
	else if (get_turn_btn())
	{
		while (get_turn_btn())
			wait1Msec(100);
		robot_mode = Turn;
		writeDebugStreamLine("Switching to Turn mode");
	}
	else if (get_follow_closest_object_mode_btn())
	{
		while (get_follow_closest_object_mode_btn())
			wait1Msec(100);
		robot_mode = Follow_Closest_Object;
		writeDebugStreamLine("Switching to Follow_Closest_Object mode");
	}
}

#define MOTOR_POWER 80
void turn_left()
{
	motor[left] = 0;//-MOTOR_POWER;
	motor[right] = MOTOR_POWER;
}

void turn_right()
{
	motor[left] = MOTOR_POWER;
	motor[right] = 0;//-MOTOR_POWER;
}

void go_straight()
{
	motor[left] = 0;//MOTOR_POWER;
	motor[right] = 0;//MOTOR_POWER;
}

void stop_moving()
{
	motor[left] = 0;
	motor[right] = 0;
}

#define RIGHT_MOTOR_ENCODING_TICKS_PER_DEGREE 10 // not the actual number
#define LEFT_MOTOR_ENCODING_TICKS_PER_DEGREE 10 // not the actual number

task sonar_scanner()
{
	nMotorEncoder[sonar_rotate] = 0;

	pid_controller_t sonar_pid_controller;
	init_sonar_pid_controller(&sonar_pid_controller);
	pid_state_t sonar_pid_state;
	init_pid_state(&sonar_pid_state, &sonar_pid_controller);

	int sonar_destination = 0;

	reset_readings();

	while (1)
	{
		// keep moving the sonar

		// turn the robot towards the closest object

		long encoder_reading = nMotorEncoder[sonar_rotate];
		long sonar_min = 0;
		long sonar_max = 720;
		sonar_pid_controller.MAX_OUTPUT = MAX_SONAR_MOTOR_SPEED;

		int closest_bin = find_closest_sonar_bin();

		switch (sonar_scan_mode)
		{
			case Sonar_Full:
				if (sonar_readings[closest_bin] < 500 && have_recent_sonar_readings())
				{
					sonar_scan_mode = Sonar_Close;
				}
				else
				{
					sonar_min = 0;
					sonar_max = 720;
					if (sonar_destination != sonar_min && sonar_destination != sonar_max)
						sonar_destination = sonar_min;
				}
				break;

			case Sonar_Close:
				if (sonar_readings[closest_bin] >= 500 || !have_recent_sonar_readings())
				{
					sonar_scan_mode = Sonar_Full;
				}
				else
				{
					sonar_min = (closest_bin - 2) * ENCODER_COUNTS_PER_BIN + 1;
					sonar_max = (closest_bin + 2) * ENCODER_COUNTS_PER_BIN;

					if (sonar_destination != sonar_min && sonar_destination != sonar_max)
						sonar_destination = sonar_min;
				}
				break;
		}

		if (encoder_reading > sonar_min - sonar_pid_controller.CLOSE_ENOUGH && encoder_reading < sonar_min + sonar_pid_controller.CLOSE_ENOUGH)
			sonar_destination = sonar_max;
		else if (encoder_reading > sonar_max - sonar_pid_controller.CLOSE_ENOUGH && encoder_reading < sonar_max + sonar_pid_controller.CLOSE_ENOUGH)
			sonar_destination = sonar_min;

		writeDebugStreamLine("using sonar_destination: %d", sonar_destination);

		long output = update_pid_controller(&sonar_pid_controller, &sonar_pid_state, sonar_destination, nMotorEncoder[sonar_rotate]);

		motor[sonar_rotate] = output;

		int reading = SensorValue[ultrasonic];
		//writeDebugStreamLine("got sonar reading: %d", reading);
		const int MIN_SONAR_DISTANCE = 30;
		if (reading > MIN_SONAR_DISTANCE)
		{
			int bin = mod(encoder_reading / ENCODER_COUNTS_PER_BIN, SONAR_BINS);
			sonar_readings[bin] = reading;
			sonar_times[bin] = nPgmTime;
		}
		wait1Msec(1);
	}
}

task main()
{

	pid_controller_t left_pid_controller;
	init_drive_pid_controller(&left_pid_controller);

	pid_controller_t right_pid_controller;
	init_drive_pid_controller(&right_pid_controller);

	reset_readings();

	while (1)
	{
		check_and_switch_mode();
		switch (robot_mode)
		{
			case Do_Nothing:
				stop_moving();
				motor[sonar_rotate] = 0;
				StopTask(sonar_scanner);
				break;
			case Turn:
				turn_left();
				break;
			case Follow_Closest_Object:
				// keep moving the sonar
				StartTask(sonar_scanner);

				// turn the robot towards the closest object
				int closest_bin = find_closest_sonar_bin();
				writeDebugStreamLine("closest_bin: %d", closest_bin);
				int degrees_to_turn = closest_bin * (360/SONAR_BINS);
				//writeDebugStreamLine("degrees_to_turn: %d", degrees_to_turn);
				while (degrees_to_turn > 180)
				{
					degrees_to_turn -= 360;
				}
				while (degrees_to_turn < -180)
				{
					degrees_to_turn += 360;
				}
				//writeDebugStreamLine("degrees_to_turn: %d", degrees_to_turn);

				if (degrees_to_turn < 360/SONAR_BINS)
				{
					move_motor_to_position(right,
						nMotorEncoder[right] + RIGHT_MOTOR_ENCODING_TICKS_PER_DEGREE * degrees_to_turn,
						&right_pid_controller);
					//turn_left();
				}
				else if (degrees_to_turn > 360/SONAR_BINS)
				{
					move_motor_to_position(left,
						nMotorEncoder[left] + LEFT_MOTOR_ENCODING_TICKS_PER_DEGREE * degrees_to_turn,
						&left_pid_controller);
					//turn_right();
				}
				else
				{
					go_straight();
				}

				wait1Msec(1);

				break;

			default:
				return;
		}
	}
}
