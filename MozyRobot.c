#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    line_follower,  sensorLineFollower)
#pragma config(Sensor, in4,    potentiometer,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  limit_switch,   sensorTouch)
#pragma config(Sensor, dgtl2,  bumper_switch,  sensorTouch)
#pragma config(Sensor, dgtl8,  ultrasonic,     sensorSONAR_mm)
#pragma config(Sensor, dgtl10, encoder,        sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           motor1,        tmotorVex393, PIDControl, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port2,           sonar_rotate,  tmotorVex393, openLoop, encoder, encoderPort, dgtl10, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define MAX(x, y) ((x) > (y) ? (x) : (y))
#define MIN(x, y) ((x) > (y) ? (y) : (x))
#define CONSTRAIN(value, min_val, max_val) (MAX(min_val, MIN(value, max_val)))

typedef struct
{
	float CLOSE_ENOUGH;
	float KP;
	float KI;
	float KD;
	long MAX_CHANGE;
	long MIN_OUTPUT;
	long MAX_OUTPUT;
	long EFFECTIVE_MIN;
	float MAX_INTEGRAL;
} pid_controller_t;

typedef struct
{
	long prev_error;
	float integral;
	long prev_output;
	float prev_derivative;
	long prev_time;
} pid_state_t;

void init_pid_state(pid_state_t* s, pid_controller_t* controller)
{
	s->prev_error = controller->CLOSE_ENOUGH + 1;
	s->integral = 0;
	s->prev_output = 0;
	s->prev_derivative = 0;
	s->prev_time = 0;
}

long update_pid_controller(pid_controller_t* controller, pid_state_t* state, long setpoint, long measured_value)
{
	long time = nPgmTime;
	long elapsed_msec = time - state->prev_time;

	// If no measurable time has passed, we can't divide by zero, so return the last output value and don't update anything
	if (elapsed_msec <= 0)
		return state->prev_output;

	long error = setpoint - measured_value;

	if (abs(error) > controller->CLOSE_ENOUGH && state->integral < controller->MAX_INTEGRAL)
		state->integral += error * elapsed_msec;

	float derivative = (float)(error - state->prev_error) / elapsed_msec;

	//writeDebugStreamLine("measured_value: %d   integral: %.2f    derivative: %.2f", measured_value, state->integral, derivative);

	float output =
			controller->KP * error
			+ controller->KI * state->integral
			+ controller->KD * derivative;

	//writeDebugStreamLine("output before correction: %.0f", output);

	output = CONSTRAIN(output,
			state->prev_output - controller->MAX_CHANGE,
			state->prev_output + controller->MAX_CHANGE);
	//writeDebugStreamLine("output after correction 1: %.0f", output);

	if (output < -1)
		output = CONSTRAIN(output, controller->MIN_OUTPUT, -controller->EFFECTIVE_MIN);
	else if (output > 1)
		output = CONSTRAIN(output, controller->EFFECTIVE_MIN, controller->MAX_OUTPUT);
	else
		output = 0;

	writeDebugStreamLine("output after correction: %d", (long)output);

	state->prev_error = error;
	state->prev_output = output;
	state->prev_derivative = derivative;
	state->prev_time = time;

	return output;
}

void move_to_position(long setpoint)
{
	pid_controller_t controller;
	controller.CLOSE_ENOUGH = 50;
	controller.KP = -0.6; //0.6 * Ku; //-1.0;
	controller.KI = -0.01;//-0.01; // 2 * KP / Tu; //-0.01;
	controller.KD = -45.0;//-5.0; //KP * Tu / 8; //-100.0;
	controller.MAX_CHANGE = 25;
	controller.MIN_OUTPUT = -127;
	controller.MAX_OUTPUT = 127;
	controller.EFFECTIVE_MIN = 20;
	controller.MAX_INTEGRAL = controller.MAX_OUTPUT / controller.KI * 2;

	pid_state_t state;
	init_pid_state(&state, &controller);

	while (abs(state.prev_error) > controller.CLOSE_ENOUGH || abs(state.prev_output) > controller.EFFECTIVE_MIN || abs(state.prev_derivative) > 0)
	{
		long output = update_pid_controller(&controller, &state, setpoint, nMotorEncoder[motor1]);

		motor[motor1] = output;

		wait1Msec(10);
	}

	motor[motor1] = 0;
}

task main()
{
	//Clear the encoders associated with the left and right motors
	nMotorEncoder[motor1] = 0;

	while (1)
	{
		//for (int i = 0; i <= 300; i += 50)
		//{
		//	move_to_position(i);
		//	wait1Msec(250);
		//}
		move_to_position(720);
		move_to_position(0);
		/*
		move_to_position(1000);
		wait1Msec(2000);
		move_to_position(0);
		wait1Msec(2000);
		wait1Msec(500);
		move_to_position(5100);
		wait1Msec(500);
		move_to_position(-100);
		wait1Msec(500);
		move_to_position(-200);
		wait1Msec(500);
		*/

		/*
		//While less than 1000 encoder counts of the right motor
		while(abs(nMotorEncoder[motor1]) < 200)
		{
			//Move forward at half power
			motor[motor1] = 100;
			//motor[leftMotor]	= 63;
		}

		motor[motor1] = 0;
	  //Clear the encoders associated with the left and right motors
		//nMotorEncoder[motor1] = 0;
		//nMotorEncoder[leftMotor] = 0;

		wait1Msec(500);

		//While less than 1000 encoder counts of the right motor
		int sign = nMotorEncoder[motor1] > 0 ? 1 : -1;
		while(sign * nMotorEncoder[motor1] > 0)
		{
			//Move in reverse at half power
			motor[motor1] = -100;
			//motor[leftMotor]	= -63;
		}

		motor[motor1] = 0;
		*/
		/*
		startMotor(motor1, 40);
		untilRotations(1.0/10.0, I2C_1);
		stopMotor(motor1);
		wait(0.2);

		startMotor(motor1, 40);
		untilRotations(1.0/10.0, I2C_1);
		stopMotor(motor1);
		wait(0.2);

		startMotor(motor1, -40);
		untilRotations(1.0/10.0, I2C_1);
		stopMotor(motor1);
		wait(0.2);

		startMotor(motor1, -40);
		untilRotations(1.0/10.0, I2C_1);
		stopMotor(motor1);
		wait(0.2);
		*/
	}


}
