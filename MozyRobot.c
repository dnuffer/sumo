#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    line1,          sensorLineFollower)
#pragma config(Sensor, in2,    line2,          sensorLineFollower)
#pragma config(Sensor, in3,    line3,          sensorLineFollower)
#pragma config(Sensor, in8,    pot1,           sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftButton,     sensorTouch)
#pragma config(Sensor, dgtl2,  rightButton,    sensorTouch)
#pragma config(Sensor, dgtl3,  spareButton1,   sensorTouch)
#pragma config(Sensor, dgtl4,  spareButton2,   sensorTouch)
#pragma config(Sensor, dgtl6,  collisionButton1, sensorTouch)
#pragma config(Sensor, dgtl9,  ultrasonicEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl11, ultrasonic,     sensorSONAR_mm)
#pragma config(Sensor, I2C_1,  leftWheelEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  rightWheelEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           sonar_rotate,  tmotorVex393, openLoop, encoder, encoderPort, dgtl9, 1000)
#pragma config(Motor,  port2,           frontLeft,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port3,           frontRight,    tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port4,           centerLeft,    tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port5,           centerRight,   tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port6,           backLeft,      tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port7,           backRight,     tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port10,          weapon,        tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define MAX_INT 32767

#define MAX(x, y) ((x) > (y) ? (x) : (y))
#define MIN(x, y) ((x) > (y) ? (y) : (x))
#define CONSTRAIN(value, min_val, max_val) (MAX(min_val, MIN(value, max_val)))

typedef struct
{
	float CLOSE_ENOUGH;
	float KP;
	float KI;
	float KD;
	long MAX_CHANGE;
	long MIN_OUTPUT;
	long MAX_OUTPUT;
	long EFFECTIVE_MIN;
	float MAX_INTEGRAL;
} pid_controller_t;

typedef struct
{
	long prev_error;
	float integral;
	long prev_output;
	float prev_derivative;
	long prev_time;
} pid_state_t;

void init_pid_state(pid_state_t* s, pid_controller_t* controller)
{
	s->prev_error = controller->CLOSE_ENOUGH + 1;
	s->integral = 0;
	s->prev_output = 0;
	s->prev_derivative = 0;
	s->prev_time = 0;
}

long update_pid_controller(pid_controller_t* controller, pid_state_t* state, long setpoint, long measured_value)
{
	long time = nPgmTime;
	long elapsed_msec = time - state->prev_time;

	// If no measurable time has passed, we can't divide by zero, so return the last output value and don't update anything
	if (elapsed_msec <= 0)
	{
		//writeDebugStreamLine("elapsed_msec == 0!");
		return state->prev_output;
	}

	long error = setpoint - measured_value;

	if (abs(error) > controller->CLOSE_ENOUGH && state->integral < controller->MAX_INTEGRAL)
		state->integral += error * elapsed_msec;

	float derivative = (float)(error - state->prev_error) / elapsed_msec;

	//writeDebugStreamLine("measured_value: %d   integral: %.2f    derivative: %.2f", measured_value, state->integral, derivative);

	float output =
			controller->KP * error
			+ controller->KI * state->integral
			+ controller->KD * derivative;

	//writeDebugStreamLine("output before correction: %.0f", output);

	output = CONSTRAIN(output,
			state->prev_output - controller->MAX_CHANGE,
			state->prev_output + controller->MAX_CHANGE);
	//writeDebugStreamLine("output after correction 1: %.0f", output);

	if (output < -1)
		output = CONSTRAIN(output, controller->MIN_OUTPUT, -controller->EFFECTIVE_MIN);
	else if (output > 1)
		output = CONSTRAIN(output, controller->EFFECTIVE_MIN, controller->MAX_OUTPUT);
	else
		output = 0;

	//writeDebugStreamLine("output after correction: %d", (long)output);

	state->prev_error = error;
	state->prev_output = output;
	state->prev_derivative = derivative;
	state->prev_time = time;

	return output;
}

const int SONAR_BINS = 12;
int sonar_readings[SONAR_BINS];
long sonar_times[SONAR_BINS];

const float ENCODER_COUNTS_PER_REV = 627.2;
const float SONAR_ENCODER_COUNTS_PER_REV = 360;
const float ENCODER_COUNTS_PER_BIN = SONAR_ENCODER_COUNTS_PER_REV / SONAR_BINS;

long mod(long x, long y)
{
	if (x < 0)
	{
		x += y * ((-x / y) + 1);
		//return x % y + y;
	}
	return x % y;
}

// This could be 127, but the sonar doesn't work very well (at all) that fast
#define MAX_SONAR_MOTOR_SPEED 40
// The docs say 15, but sometimes even 15 doesn't move. 20 is pretty reliable for a slow movement.
#define MIN_MOTOR_SPEED 30

void init_sonar_pid_controller(pid_controller_t* controller)
{
	controller->CLOSE_ENOUGH = 15;
	controller->KP = -0.6; //0.6 * Ku; //-1.0;
	controller->KI = -0.01;//-0.01; // 2 * KP / Tu; //-0.01;
	controller->KD = -45.0;//-5.0; //KP * Tu / 8; //-100.0;
	controller->MAX_CHANGE = 75;
	controller->MAX_OUTPUT = MAX_SONAR_MOTOR_SPEED;
	controller->MIN_OUTPUT = -controller->MAX_OUTPUT;
	controller->EFFECTIVE_MIN = MIN_MOTOR_SPEED;
	controller->MAX_INTEGRAL = controller->MAX_OUTPUT / controller->KI * 2;
}

void init_drive_pid_controller(pid_controller_t* controller)
{
	controller->CLOSE_ENOUGH = 15;
	controller->KP = -0.6; //0.6 * Ku; //-1.0;
	controller->KI = -0.01;//-0.01; // 2 * KP / Tu; //-0.01;
	controller->KD = -45.0;//-5.0; //KP * Tu / 8; //-100.0;
	controller->MAX_CHANGE = 75;
	controller->MAX_OUTPUT = 127;
	controller->MIN_OUTPUT = -controller->MAX_OUTPUT;
	controller->EFFECTIVE_MIN = 80;
	controller->MAX_INTEGRAL = controller->MAX_OUTPUT / controller->KI * 2;
}

void move_motor_to_position(int motor_id, long desired_encoder, pid_controller_t* controller, int extra_motor1, int extra_motor2)
{
	pid_state_t state;
	init_pid_state(&state, controller);

	while (abs(state.prev_error) > controller->CLOSE_ENOUGH)
	{
		long output = update_pid_controller(controller, &state, desired_encoder, nMotorEncoder[motor_id]);
		motor[motor_id] = output;
		motor[extra_motor1] = output;
		motor[extra_motor2] = output;
		wait1Msec(1);
	}

	motor[motor_id] = 0;
	motor[extra_motor1] = 0;
	motor[extra_motor2] = 0;
}

void move_to_position(long setpoint)
{
	pid_controller_t controller;
	init_sonar_pid_controller(&controller);
	pid_state_t state;
	init_pid_state(&state, &controller);

	while (abs(state.prev_error) > controller.CLOSE_ENOUGH)
	{
		long output = update_pid_controller(&controller, &state, setpoint, nMotorEncoder[sonar_rotate]);

		motor[sonar_rotate] = output;

		int reading = SensorValue[ultrasonic];
		long encoder_reading = nMotorEncoder[sonar_rotate];
		const int MIN_SONAR_DISTANCE = 30;
		if (reading > MIN_SONAR_DISTANCE)
		{
			int bin = mod(encoder_reading / ENCODER_COUNTS_PER_BIN, SONAR_BINS);
			sonar_readings[bin] = reading;
			sonar_times[bin] = nPgmTime;
		}
		wait1Msec(10);
	}

	motor[sonar_rotate] = 0;
}

#define Sonar_Full 0
#define Sonar_Close 1
int sonar_scan_mode = Sonar_Full;

void reset_readings()
{
	for (int i = 0; i < SONAR_BINS; i++)
	{
		sonar_readings[i] = MAX_INT;
		sonar_times[i] = -1;
	}
}

int find_closest_sonar_bin()
{
	int min_idx = 0;
	for (int i = 1; i < SONAR_BINS; i++)
	{
		if (sonar_readings[i] < sonar_readings[min_idx])
			min_idx = i;
	}
	return min_idx;
}

void print_closest()
{
	int min_idx = find_closest_sonar_bin();
	writeDebugStreamLine("closest is at %d deg, distance of %d mm", min_idx * 360/SONAR_BINS, sonar_readings[min_idx]);
}

bool have_recent_sonar_readings()
{
	long cur_time = nPgmTime;
	long max_age = 5 * 1000;
	for (int i = 0; i < SONAR_BINS; i++)
	{
		if (sonar_times[i] < cur_time - max_age || sonar_times[i] == -1 || sonar_readings[i] == MAX_INT)
			return false;
	}
	return true;
}

#define Turn 0
#define Follow_Closest_Object 1
#define Do_Nothing 2
#define Direct_Drive 3
int robot_mode = Do_Nothing;

int get_do_nothing_mode_btn()
{
	return vexRT[Btn7D] || SensorValue[spareButton2];
}

int get_follow_closest_object_mode_btn()
{
	return vexRT[Btn8U] || SensorValue[spareButton1];
}

int get_collision_button()
{
	return vexRT[Btn8D] || SensorValue[collisionButton1];
}

bool get_toggle_rc_mode_btn()
{
	return (vexRT[Btn7U] == 1);
}

void do_direct_drive()
{
	while (!get_toggle_rc_mode_btn())
	{
		// direct drive
  	motor[frontLeft] = vexRT[Ch3];
  	motor[centerLeft] = vexRT[Ch3];
  	motor[backLeft] = vexRT[Ch3];
  	motor[frontRight] = vexRT[Ch2];
  	motor[centerRight] = vexRT[Ch2];
  	motor[backRight] = vexRT[Ch2];
	}

	while (get_toggle_rc_mode_btn())
	{
		wait1Msec(100);
	}
}


#define MAX_MOTOR_POWER 127
#define MOTOR_POWER 80
void turn_left()
{
	motor[frontLeft] = 0;//-MOTOR_POWER;
	motor[centerLeft] = 0;//-MOTOR_POWER;
	motor[backLeft] = 0;//-MOTOR_POWER;
	motor[frontRight] = MOTOR_POWER;
	motor[centerRight] = MOTOR_POWER;
	motor[backRight] = MOTOR_POWER;
}

void turn_right()
{
	motor[frontLeft] = MOTOR_POWER;
	motor[centerLeft] = MOTOR_POWER;
	motor[backLeft] = MOTOR_POWER;
	motor[frontRight] = 0;//-MOTOR_POWER;
	motor[centerRight] = 0;//-MOTOR_POWER;
	motor[backRight] = 0;//-MOTOR_POWER;
}

void go_straight_with_power(int power)
{
	motor[frontLeft] = power;
	motor[centerLeft] = power;
	motor[backLeft] = power;
	motor[frontRight] = power;
	motor[centerRight] = power;
	motor[backRight] = power;
}

void go_straight(bool forward)
{
	int power = forward ? MOTOR_POWER : -MOTOR_POWER;
	go_straight_with_power(power);
}

void stop_moving()
{
	motor[frontLeft] = 0;
	motor[centerLeft] = 0;
	motor[backLeft] = 0;
	motor[frontRight] = 0;
	motor[centerRight] = 0;
	motor[backRight] = 0;
}

#define RIGHT_MOTOR_ENCODING_TICKS_PER_DEGREE 10 // not the actual number
#define LEFT_MOTOR_ENCODING_TICKS_PER_DEGREE 10 // not the actual number

task sonar_scanner()
{
	pid_controller_t sonar_pid_controller;
	init_sonar_pid_controller(&sonar_pid_controller);
	pid_state_t sonar_pid_state;
	init_pid_state(&sonar_pid_state, &sonar_pid_controller);

	int sonar_destination = 0;

	reset_readings();

	sonar_scan_mode = Sonar_Full;
	sonar_pid_controller.MAX_OUTPUT = MAX_SONAR_MOTOR_SPEED;

	while (1)
	{
		// keep moving the sonar

		// turn the robot towards the closest object

		long encoder_reading = nMotorEncoder[sonar_rotate];
		long sonar_min = 0;
		long sonar_max = 400;

		int closest_bin = find_closest_sonar_bin();

		switch (sonar_scan_mode)
		{
			case Sonar_Full:
				//if (sonar_readings[closest_bin] < 500 && have_recent_sonar_readings())
				//{
				//	sonar_scan_mode = Sonar_Close;
				//}
				//else

				{
					sonar_min = 0;
					sonar_max = 400;
					//if (sonar_destination != sonar_min && sonar_destination != sonar_max)
					//	sonar_destination = sonar_min;
				}
				break;

			case Sonar_Close:
				if (sonar_readings[closest_bin] >= 500 || !have_recent_sonar_readings())
				{
					sonar_scan_mode = Sonar_Full;
				}
				else
				{
					sonar_min = (closest_bin - 2) * ENCODER_COUNTS_PER_BIN + 1;
					sonar_max = (closest_bin + 2) * ENCODER_COUNTS_PER_BIN;

					if (sonar_destination != sonar_min && sonar_destination != sonar_max)
						sonar_destination = sonar_min;
				}
				break;
		}

		if (encoder_reading > sonar_min - sonar_pid_controller.CLOSE_ENOUGH && encoder_reading < sonar_min + sonar_pid_controller.CLOSE_ENOUGH)
			sonar_destination = sonar_max;
		else if (encoder_reading > sonar_max - sonar_pid_controller.CLOSE_ENOUGH && encoder_reading < sonar_max + sonar_pid_controller.CLOSE_ENOUGH)
			sonar_destination = sonar_min;

		writeDebugStreamLine("using sonar_destination: %d", sonar_destination);

		long output = update_pid_controller(&sonar_pid_controller, &sonar_pid_state, sonar_destination, nMotorEncoder[sonar_rotate]);

		motor[sonar_rotate] = output;

		int reading = SensorValue[ultrasonic];
		//writeDebugStreamLine("got sonar reading: %d", reading);
		const int MIN_SONAR_DISTANCE = 30;
		if (reading > MIN_SONAR_DISTANCE)
		{
			int bin = mod(encoder_reading / ENCODER_COUNTS_PER_BIN, SONAR_BINS);
			sonar_readings[bin] = reading;
			sonar_times[bin] = nPgmTime;
		}
		wait1Msec(1);
	}
}

#define SUMO_STOP 0
#define SUMO_CHASE 1
#define SUMO_FWD_PUSH 2
#define SUMO_BCK_PUSH 3
#define SUMO_SPIN 4

//sensor reading functions
int bump_detect_front()
{
	//code to return value of front bump button
	return 0;
}
int bump_detect_back()
{
	//code to return value of back bump button
	return 0;
}
int side_detect()
{
	//code to return left side bump button OR'd with right side bump button
	return 0;
}
int line_detect()
{
	//code to line presense
	return 0;
}

int sumo_stop_state()
{
	return SUMO_CHASE;
}
int sumo_chase_state()
{
	while (1)
	{
		//sonar follow code

		//state transition on sensor input
		if (bump_detect_front())
			return SUMO_FWD_PUSH;
		if (bump_detect_back())
			return SUMO_BCK_PUSH;
		if (line_detect())
			return SUMO_STOP;
		if (side_detect())
			return SUMO_SPIN;
	}
}
int sumo_push_fwd_state()
{
	while (1)
	{
		//drive forward code

		//state transition on sensor input
		if (!bump_detect_front()) //release of contact
			return SUMO_STOP;
		if (bump_detect_back())
			return SUMO_BCK_PUSH;
		if (line_detect())
			return SUMO_STOP;
		if (side_detect())
			return SUMO_SPIN;
	}
}
int sumo_push_bck_state()
{
	while (1)
	{
		//drive backward code

		//state transition on sensor input
		if (!bump_detect_back()) //release of contact
			return SUMO_STOP;
		if (bump_detect_front())
			return SUMO_FWD_PUSH;
		if (line_detect())
			return SUMO_STOP;
		if (side_detect())
			return SUMO_SPIN;
	}
}
int sumo_spin_state()
{
	while (1)
	{
		//code to spin in either direction

		//state transition on sensor input
		if (bump_detect_front()) //release of contact
			return SUMO_FWD_PUSH;
		if (bump_detect_back())
			return SUMO_BCK_PUSH;
		if (line_detect())
			return SUMO_STOP;
		if (!side_detect())
			return SUMO_STOP;
	}
}

void sumo_mode_loop()
{
	int sumo_state = SUMO_STOP;
	while (1)
	{
		switch (sumo_state)
		{
			case SUMO_STOP:
			sumo_state = sumo_stop_state();
			break;
			case SUMO_CHASE:
			sumo_state = sumo_chase_state();
			break;
			case SUMO_FWD_PUSH:
			sumo_state = sumo_push_fwd_state();
			break;
			case SUMO_BCK_PUSH:
			sumo_state = sumo_push_bck_state();
			break;
			case SUMO_SPIN:
			sumo_state = sumo_spin_state();
			break;
		}
	}
}

/********************************** Defines *****************************************/

// Particle filter parameters and settings
#define ENC_NOISE 0.15        // noise as fraction of commanded distance or angle
#define LINE_SENS_NOISE 200.0  // noise of line sensor reading
#define PART_XY_NOISE 50.0		// noise in initial positional placement of robot in mm
#define PART_Q_NOISE 0.0523  	// noise in initial positional placement of robot in rad
#define NUM_PRTCL 100					// number of particles *** NOTE update floating point value below as well
#define F_NUM_PRTCL 100.0     // floating point representation of number of particles *** change with above
#define ESS_THRESH 0.2				// resampling threshold

// Physical characteristics of robot
#define NUM_SENSORS 3					// number of sensors
#define RADIUS 52						  // tyre radius (mm)
#define ROBOT_DIAM 317.5			// distance between turning point of wheels (mm)
//#define MM_TO_ENC (180.0 / (PI * RADIUS))
#define MM_TO_ENC (ENCODER_COUNTS_PER_REV / (2.0 * PI * RADIUS))
#define ENC_TO_MM (1.0/MM_TO_ENC)
//#define DEG_TO_ENC ((ROBOT_DIAM * ENCODER_COUNTS_PER_REV) / (2.0 * RADIUS))
// multiply by degrees of desired turn, and get the number of encoder counts to run forward one side motor
#define DEG_TO_ENC ((ROBOT_DIAM * ENCODER_COUNTS_PER_REV) / (360 * RADIUS))

// Starting position and angle
#define START_X 0.0
#define START_Y 0.0
#define START_Q 0.0

// Handy constants
#define TWO_PI 6.28318530718
#define PI_ON_TWO 1.5707963268
#define BIG_NUMBER 999999.0

// TODO: Measure these!
// values given where the robot is on the playing field.
#define WHITE_SENSOR_READING 300.0
#define RED_SENSOR_READING 1000.0
#define BLACK_SENSOR_READING 2000.0

#define MAP_WHITE_RADIUS 914.4 // mm
#define MAP_BLACK_RADIUS (MAP_WHITE_RADIUS + 50.0) // mm

/****************************** Constants *******************************/
// Sensors
// TODO: measure this once the sensors are actually mounted
const float sens_x[3] = {-60.0,  0.0,  60.0}; // x coords of sensors in robot coord frame
const float sens_y[3] = {-85.0, 60.0, -85.0}; // y coords of sensors in robot coord frame

// Precompute some handy numbers
const float	ess_thresh = ESS_THRESH * F_NUM_PRTCL;
const float	sens_dist_noise_2sq = 2.0 * LINE_SENS_NOISE * LINE_SENS_NOISE;


/****************************** Globals **********************************/

// Particle filter storage
float particle_x [NUM_PRTCL];
float particle_y [NUM_PRTCL];
float particle_q [NUM_PRTCL];
float particle_w [NUM_PRTCL];

// Sensor readings
int sensor_reading[NUM_SENSORS];

// Interprocess variables
float avg_x, avg_y, avg_q;  // Pose reported by filter
float dist, dq;							// Commanded distance and angle from motion planner


/******************************************************************************
*															Function definitions                            *
******************************************************************************/

/*************************** Utility functions *******************************/

// float uniform_rand() - Produces floating point random number between [0,1)
float uniform_rand()
{
	return ((float)(random(32766))/ 32767.0);
}

// float normal_rand() - Produces random number for Gaussian distribution with mean = 0 and sd = 1.
// Based on Box-Muller transformation.
float normal_rand()
{
	return sqrt(-2.0 * log(uniform_rand())) * cos(2.0 * PI * uniform_rand());
}

// void atan2(float y, float x, float &q) - Computes atan2() but returns value in parameter
void atan2(float y, float x, float &q)
{
	if (x > 0.0) {
		q = atan(y/x);
		return;
	}
	if (x < 0.0) {
		if (y >= 0.0) {
			q = PI + atan(y/x);
			return;
		}
		q = -PI + atan(y/x);
		return;
	}
	if (y > 0.0) { // x == 0
		q = PI_ON_TWO;
		return;
	}
	if (y < 0.0) {
		q = -PI_ON_TWO;
		return;
	}
	q = 0.0; // Should really be undefined
	return;
}

// void limit_ang(float &angle) - brings an angle back between +- PI
// BEWARE: make sure this is called frequently on all angular variables or else it can take a
// long time to unwind a angular number that has been rotated many times. Could be implemented better.
void limit_ang(float &angle)
{
	while (angle > PI)
		angle -= TWO_PI;
	while (angle < -PI)
		angle += TWO_PI;
}

/***************************** Particle filter functions *********************/

// void read_line_sensors () - Read the sensors and put the values in range. Invalid
// sensor readings are set to BIG_NUMBER
void read_line_sensors ()
{
	int n;
	int raw_s[3];

  raw_s[0] = SensorValue[line1];
  raw_s[1] = SensorValue[line2];
  raw_s[2] = SensorValue[line3];

	for (n = 0; n < NUM_SENSORS; n++) {
		if ((raw_s[n] > 3000) || (raw_s[n] < 10)) {
			sensor_reading[n] = MAX_INT;
		}	else {
			sensor_reading[n] = raw_s[n];
		}
	}
}

bool all_sensors_on_white()
{
	read_line_sensors();

	for( int i = 0; i < NUM_SENSORS; ++i )
	{
		if( sensor_reading[i] >= RED_SENSOR_READING )
		{
			return false;
		}
	}
	return true;
}

// resample variables which need to be globals instead of stack vars because there are too many
float new_x [NUM_PRTCL];
float new_y [NUM_PRTCL];
float new_q [NUM_PRTCL];
int index[NUM_PRTCL];
int x[NUM_PRTCL];
float q [NUM_PRTCL];
float r [NUM_PRTCL];

// void resample () - Resample the particles using Select with Replacement.
void resample ()
{
	int i, j;
	float uniform_weight;

	// Produce cumulative distribution
	q[0] = particle_w[0];
	for (i = 1; i < NUM_PRTCL; i++) {
		q[i] = q[i-1] + particle_w[i];
	}

	// Produce a list of random integers with an ordering index
	for (i = 0; i < NUM_PRTCL; i++) {
		x[i] = random(32766);
		index[i] = 0;
		for (j = 0; j < i; j++) {
			if (x[j] < x[i]) {
				if (index[i] <= index[j]) {
					index[i] = index[j] + 1;
				}
			} else {
				index[j]++;
			}
		}
	}
	// Put numbers out in order using index, scale and cast list to floats
	for (i = 0; i < NUM_PRTCL; i++) {
		r[index[i]] = (float)(x[i]) / 32767.0;
	}

	// Make copies of particles as many times as the sorted random numbers appear
	// between the cumulative distribution values
	i = 0;
	j = 0;
  while (i < NUM_PRTCL) {
  	if (r[i] < q[j]) {
  		new_x[i] = particle_x[j];
  		new_y[i] = particle_y[j];
  		new_q[i] = particle_q[j];
      i = i + 1;
    } else {
      j = j + 1;
    }
	}

	// Put the copies into the particle list and reset weights
	uniform_weight = 1.0 / F_NUM_PRTCL;
	for (i = 0; i < NUM_PRTCL; i++) {
		particle_x[i] = new_x[i];
		particle_y[i] = new_y[i];
		particle_q[i] = new_q[i];
		particle_w[i] = uniform_weight;
	}
}

// float get_reading(int n, float px, float py, float pq) - Work out what sensor
// reading for sensor number n should be if robot is in pose (px, py, pq) using
// information in map
float get_reading(int n, float px, float py, float pq)
{
	// Update particle position to account sensor position
	// wrt to turning axis of robot.
	float cpq = cos(pq);
	float spq = sin(pq);
	float sensor_x = sens_x[n] * cpq - sens_y[n] * spq ;
	float sensor_y = sens_x[n] * spq + sens_y[n] * cpq ;

	float dist_from_center = sqrt(sensor_x * sensor_x + sensor_y * sensor_y);
	if (dist_from_center < MAP_WHITE_RADIUS)
	{
		return WHITE_SENSOR_READING;
	}
	else if (dist_from_center < MAP_BLACK_RADIUS)
	{
		return BLACK_SENSOR_READING;
	}
	else
	{
		return RED_SENSOR_READING;
	}
}

// void init_particles(int particle_seed) - Initialise particles with a spread
// to express uncertainty in robot placement at start of test
void init_particles(int particle_seed)
{
	int i;
	float uniform_weight;

	srand(particle_seed);
	uniform_weight = 1.0 / F_NUM_PRTCL;
	for (i = 0; i < NUM_PRTCL; i++) {
		particle_x[i] = START_X + (normal_rand() * PART_XY_NOISE);
		particle_y[i] = START_Y + (normal_rand() * PART_XY_NOISE);
		particle_q[i] = START_Q + (normal_rand() * PART_Q_NOISE);
		particle_w[i] = uniform_weight;
	}
}

long prev_left_encoder = 0;
long prev_right_encoder = 0;

// void predict_particles() - Predict the position of particles based on commanded movement
// and adding process noise
void predict_particles()
{
	long left_encoder = nMotorEncoder[centerLeft];
	long right_encoder = nMotorEncoder[centerRight];

	// Predict
	for (int i = 0; i < NUM_PRTCL; i++)
	{
		long left_d = (left_encoder - prev_left_encoder) * (1.0 + normal_rand() * ENC_NOISE);
		long right_d = (right_encoder - prev_right_encoder) * (1.0 + normal_rand() * ENC_NOISE);
		float left_d_mm = ENC_TO_MM * left_d;
		float right_d_mm = ENC_TO_MM * right_d;
		if (left_d_mm != right_d_mm)
		{
			float inner_d_mm;
			float outer_d_mm;
			int direction;
			if (left_d_mm < right_d_mm)
			{
				inner_d_mm = left_d_mm;
				outer_d_mm = right_d_mm;
				direction = -1;
			}
			else
			{
				inner_d_mm = right_d_mm;
				outer_d_mm = left_d_mm;
				direction = 1;
			}
			float internal_radius =
					- (inner_d_mm * ROBOT_DIAM) / (inner_d_mm - outer_d_mm);
			float theta = (outer_d_mm - inner_d_mm) / ROBOT_DIAM;

			float turn_x = particle_x[i] + (internal_radius + ROBOT_DIAM / 2) * cos(particle_q[i] + direction * PI_ON_TWO);
			float turn_y = particle_y[i] + (internal_radius + ROBOT_DIAM / 2) * sin(particle_q[i] + direction * PI_ON_TWO);

			particle_x[i] = turn_x + (internal_radius + ROBOT_DIAM / 2) * cos(particle_q[i] + direction * PI_ON_TWO - theta);
			particle_y[i] = turn_y + (internal_radius + ROBOT_DIAM / 2) * sin(particle_q[i] + direction * PI_ON_TWO - theta);
			particle_q[i] += theta;

			limit_ang(particle_q[i]);
		}
		else // left_d_mm == right_d_mm
		{
			// just moved straight
			particle_x[i] += left_d_mm * cos(particle_q[i]);
			particle_y[i] += left_d_mm * sin(particle_q[i]);
		}
	}

	prev_left_encoder = left_encoder;
	prev_right_encoder = right_encoder;
}

// void update_weights() - Update the weights based on the current range readings
// and the quality of match of the readings to the map
void update_weights()
{
	for (int n = 0; n < NUM_SENSORS; n++) {
	  if (sensor_reading[n] != BIG_NUMBER) {
			for (int i = 0; i < NUM_PRTCL; i++) {
				float expected_reading = get_reading(n, particle_x[i], particle_y[i], particle_q[i]);
				if (expected_reading != BIG_NUMBER) {
					float dist_err = sensor_reading[n] - expected_reading;
			    particle_w[i] *= exp(-dist_err * dist_err / sens_dist_noise_2sq);
			  }
		  }
		}
	}
}

// float normalise_weights() - Normalise the weights to sum to 1.0. Returns original sum
// value principally to check for all zero weights which means we're lost
float normalise_weights()
{
	float sum;
	int i;

	sum = 0.0;
	for (i = 0; i < NUM_PRTCL; i++) {
    sum += particle_w[i];
	}
	if (sum != 0.0) {
		for (i = 0; i < NUM_PRTCL; i++) {
	    particle_w[i] /= sum;
	  }
	}
	return sum;
}

// void update_averages() - Computes the weighted average of the particles. NOTE Prone
// to error if multi-modal distribution. Should really find mode and only use particles
// near mode.
void update_averages()
{
	int i;
	float a_x, a_y, a_cq, a_sq;

	a_x  = 0.0;
	a_y  = 0.0;
	a_cq = 0.0;
	a_sq = 0.0;
	for (i = 0; i < NUM_PRTCL; i++) {
    a_x += particle_x[i] * particle_w[i];
    a_y += particle_y[i] * particle_w[i];
    // Compute using quadrature components to prevent problems at +/- PI
    a_cq += cos(particle_q[i]) * particle_w[i];
    a_sq += sin(particle_q[i]) * particle_w[i];
	}
	avg_x = a_x;
	avg_y = a_y;
	atan2(a_sq, a_cq, avg_q);
}

// float compute_ess() - Returns ess calculation to check information quality
// of particles
float compute_ess()
{
	int i;
	float sum, temp;

	// Check ESS
	sum = 0.0;
	for (i = 0; i < NUM_PRTCL; i++) {
		temp = F_NUM_PRTCL * particle_w[i] - 1.0;
		sum += temp * temp;
	}
	return(F_NUM_PRTCL / (1.0 + sum / F_NUM_PRTCL));
}


task location_updater()
{
	float ess = 0.0, sum = 0.0;

	// Initialize position
	avg_x = 0.0;
	avg_y = 0.0;
	avg_q = 0.0;

	// Initialise particles with a random seed
	init_particles(nSysTime);

	// Set the initial movement to zero
	dist = 0.0;
	dq = 0.0;

	while (1)
	{

		// Predict the position of the particles based on the last movement command
		predict_particles();

		// Sense
		read_line_sensors();

		// Update weights
		update_weights();

		// Normalise and check for zero weights
		sum = normalise_weights();

		// If all weights are zero then we are REALLY lost
		if (sum == 0.0) {
			init_particles(nSysTime);
			continue;
		}

		// Compute weighted average position of particles
		update_averages();

		// Let the blocked movement task run now we are localised
		//if (wait_for_filter > 0)
		//	wait_for_filter--;

		// Resample if necessary
		ess = compute_ess();
		if (ess < ess_thresh) {
			resample();
		}

		// Wait for movement to finish before looping
		//wait_for_drive = 1;
		//while (wait_for_drive > 0) {
		//	wait1Msec(1);
		//}

		wait1Msec(10);
	}
}
void switch_to_follow_closest_object() {
	// keep moving the sonar
	StartTask(sonar_scanner);

	while (!have_recent_sonar_readings())
	{
		wait1Msec(100);
		break;
	}
	robot_mode = Follow_Closest_Object;
}

void check_and_switch_mode()
{
	if (get_do_nothing_mode_btn())
	{
		while (get_do_nothing_mode_btn())
			wait1Msec(100);

		robot_mode = Do_Nothing;
		StopTask(sonar_scanner);

		stop_moving();
		motor[sonar_rotate] = 0;
		//nMotorEncoder[centerRight] = 0;
		writeDebugStreamLine("Switching to Do_Nothing mode");
	}
	else if (get_follow_closest_object_mode_btn())
	{
		while (get_follow_closest_object_mode_btn())
			wait1Msec(100);
		switch_to_follow_closest_object();
		writeDebugStreamLine("Switching to Follow_Closest_Object mode");
	}	else if (get_toggle_rc_mode_btn())
	{
		while (get_toggle_rc_mode_btn())
			wait1Msec(100);
		int previous_mode = robot_mode;
		robot_mode = Direct_Drive;

		writeDebugStreamLine("Switching to Direct_Drive mode");

		// only returns when user pushes drive button again
		do_direct_drive();

		writeDebugStreamLine("Returning to previous mode");
		robot_mode = previous_mode;
	}
}

#define WanderMode 4
#define ContactMode 5

int random_sign()
{
	if( random(1) > 0 )
	{
		return 1;
	}
	return -1;
}

#define PROBISCUS_UP 1600
#define PROBISCUS_DOWN 3650

void move_probiscus_to_position(int value)
{
	int sensor = SensorValue[pot1];
	if( sensor < value )
	{
		do
		{
			// GO UP.
			motor[weapon] = 1.5*MIN(-(MAX_MOTOR_POWER * (value - sensor) / (PROBISCUS_DOWN - PROBISCUS_UP)), -30);
			wait1Msec(1);
			sensor = SensorValue[pot1];
		}
		while( sensor < value );
	}
	else
	{
		do
		{
			// GO DOWN
			motor[weapon] = 1.5*MAX((MAX_MOTOR_POWER * (sensor - value) / (PROBISCUS_DOWN - PROBISCUS_UP)), 30);
			wait1Msec(1);
			sensor = SensorValue[pot1];
		}
		while( sensor > value );
	}
	motor[weapon] = 0;
}

void raise_probiscus()
{
	writeDebugStreamLine("Raising");
	move_probiscus_to_position(PROBISCUS_UP);
}

void lower_probiscus()
{
	writeDebugStreamLine("Lowering");
	move_probiscus_to_position(PROBISCUS_DOWN);
}

void ramming_speed()
{
	go_straight_with_power(MAX_MOTOR_POWER);
}

task main
{
  nMotorEncoder[centerRight] = 0;
  nMotorEncoder[centerLeft] = 0;
	bool going_forward = true;

	pid_controller_t left_pid_controller;
	init_drive_pid_controller(&left_pid_controller);

	pid_controller_t right_pid_controller;
	init_drive_pid_controller(&right_pid_controller);

	raise_probiscus();
	lower_probiscus();

	int off_white_count = 0;
	while (true)
	{
    go_straight(going_forward);
		wait1Msec(1);
		if (!all_sensors_on_white())
		{
			off_white_count++;
		}
		else
		{
			off_white_count = 0;
		}

		if (off_white_count > 100)
		{
			going_forward = !going_forward;
			go_straight(going_forward);
			while (off_white_count > 0)
			{
				if (all_sensors_on_white())
					off_white_count--;
				else
					off_white_count = 100;

				wait1Msec(1);
			}
		}
		else if( get_collision_button() )
		{
			// Raise, shoot forward.
			raise_probiscus();
			ramming_speed();
			wait1Msec(1000);
			lower_probiscus();
		}
		else
		{
			int turn_percentage = random(255);
			//writeDebugStreamLine("turn_percentage: %d, rnd: %d", turn_percentage, random(100));
			if (turn_percentage > 254 && off_white_count == 0)
		  {
				// Initiate a random turn for a random duration up to 500 msec.
		  	int value1 = 127 * random_sign();
		  	int value2 = 127 * random_sign();
		  	//writeDebugStreamLine("value1: %d, value2: %d, random(100): %d", value1, value2, random(100));

		  	motor[frontLeft] = value1;
		  	motor[centerLeft] = value1;
		  	motor[backLeft] = value1;

		  	motor[frontRight] = value2;
		  	motor[centerRight] = value2;
		  	motor[backRight] = value2;

		  	int to_wait = random(100) * 5;
		  	for (int i = 0; i < to_wait; i++)
		  	{
		  		if (!all_sensors_on_white())
		  			break;
		  		wait1Msec(1);
		  	}
			}
		}
	}
}

void future_task_main()
{
	nMotorEncoder[sonar_rotate] = 0;
  nMotorEncoder[centerRight] = 0;
  nMotorEncoder[centerLeft] = 0;

	pid_controller_t left_pid_controller;
	init_drive_pid_controller(&left_pid_controller);

	pid_controller_t right_pid_controller;
	init_drive_pid_controller(&right_pid_controller);

	reset_readings();

	StartTask(location_updater);

	while (1)
	{
		check_and_switch_mode();
		switch (robot_mode)
		{
			case Do_Nothing:
				break;
			case Turn:
				turn_left();
				break;
			case Follow_Closest_Object:
				// turn the robot towards the closest object
				int closest_bin = find_closest_sonar_bin();
				writeDebugStreamLine("closest_bin: %d", closest_bin);
				int degrees_to_turn = closest_bin * (360/SONAR_BINS);
				//writeDebugStreamLine("degrees_to_turn: %d", degrees_to_turn);
				while (degrees_to_turn > 180)
				{
					degrees_to_turn -= 360;
				}
				while (degrees_to_turn < -180)
				{
					degrees_to_turn += 360;
				}
				//writeDebugStreamLine("degrees_to_turn: %d", degrees_to_turn);

				if (degrees_to_turn < 360/SONAR_BINS)
				{
					// TODO: what about other motors on that side?
					move_motor_to_position(centerRight,
						nMotorEncoder[centerRight] + DEG_TO_ENC * degrees_to_turn,
						&right_pid_controller,  frontRight, backRight);
					//turn_left();
				}
				else if (degrees_to_turn > 360/SONAR_BINS)
				{
					// TODO: what about other motors on that side?
					move_motor_to_position(centerLeft,
						nMotorEncoder[centerLeft] + DEG_TO_ENC * degrees_to_turn,
						&left_pid_controller, frontLeft, backLeft);
					//turn_right();
				}
				else
				{
					go_straight(true);
				}

				wait1Msec(1);

				break;

			default:
				return;
		}
	}
}
